- allow for a "partial" interface. a partial interface is one which requires more than
  what is defined in the contract. this can be useful for a number of reasons:
- uses:
  âœ… primitive-friendly parameterization
  - interfaces that require static methods
  - non-public methods in interface (bad idea?)
  - constructor constraints?

todo:
  - support use of eg List<T>
  - support use of eg T<String>
  - support use of eg T<X>
  - use in abstract class (not interface)

caveats:
- for now, you have to call PartialInterface.check() at clinit time.
- refactoring cannot be done automatically in an IDE
- varargs must be specified as eg int[].class, as under the covers that is how java treats it.

questions:
- how can check() be triggered automatically at clinit time of the child class?

design notes:
- use class annotations, not method annotations, b/c of potential return type confusion
- use classgraph instead of ctor checks b/c an interface cannot run code at init or clinit time.
