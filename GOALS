- allow for a "partial" interface. a partial interface is one which requires more than
  what is defined in the contract. this can be useful for a number of reasons:
- uses:
  âœ… primitive-friendly parameterization
  - interfaces that require static methods
  - non-public methods in interface (bad idea?)
  - constructor constraints?

todo:
  - support use of eg T<String>
  - use in abstract class (not interface)

questions:
- support use of eg List<T> -- will not work if T is primitive
  - could be supported with some alternative, eg Stream<T> for int would be an IntStream
- support use of eg T<X> -- will not work if X is primitive.
- how can check() be triggered automatically at clinit time of the child class?

caveats:
- for now, you have to call PartialInterface.check() at clinit time.
- refactoring cannot be done automatically in an IDE
- varargs must be specified as eg int[].class, as under the covers that is how java treats it.

design notes:
- use class annotations, not method annotations, b/c of potential return type confusion
- use classgraph instead of ctor checks b/c an interface cannot run code at init or clinit time.
