- allow for a "partial" interface. a partial interface is one which requires more than
  what is defined in the contract. this can be useful for a number of reasons:
- uses:
  âœ… primitive-friendly parameterization
  - interfaces that require static methods
  - non-public methods in interface (bad idea?)
  - constructor constraints?

todo:
  - support autoboxing eg. if Foo<T> required and T = int.class, expect Foo<Integer> instead
  - support type parameters with constraints, eg class Foo<T extends Number>

questions:
- alternative to boxing support of eg Stream<T>
  - could be supported with some alternative, eg Stream<T> for int would be an IntStream

caveats:
- refactoring cannot be done automatically in an IDE
- varargs must be specified as eg int[].class, as under the covers that is how java treats it.

design notes:
- use class annotations, not method annotations, b/c of potential return type confusion
- use classgraph instead of ctor checks b/c an interface cannot run code at init or clinit time.
