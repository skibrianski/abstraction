- allow for a "partial" interface. a partial interface is one which requires more than
  what is defined in the contract. this can be useful for a number of reasons:
  - âœ… primitive-friendly parameterization
    - when T = int.class, implementing `T sum(List<T> list)` is fulfilled via `int sum(List<Integer> list)`
  - interfaces that require static methods
  - non-public methods in interface (bad idea?)
  - constructor constraints?

todo:
  - rename. maybe @Trait (what rust calls it) or just @Abstraction ?
  - do we need a solution for loading all child classes of the classes *used* by the partialInterface?
  - how do wildcard types and boxing interact?
  - test for / support type constraints that reference other types, eg Foo<T extends Number, U extends T>
  - think: how precise do we want to be about boxing? when T = int.class, should you be able to implement
     `T sum(List<T> list)` with `Integer sum(List<T> list)` ? what is our current behavior?

questions:
- alternative to boxing support of eg Stream<T>
  - could be supported with some alternative, eg Stream<T> for int would be an IntStream

caveats:
- refactoring cannot be done automatically in an IDE
- varargs must be specified as eg int[].class, as under the covers that is how java treats it.

design notes:
- use class annotations, not method annotations, b/c of potential return type confusion
- use classgraph instead of ctor checks b/c an interface cannot run code at init or clinit time.
